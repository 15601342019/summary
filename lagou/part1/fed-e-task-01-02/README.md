# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()  // 10
```

　

　

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp); // ReferenceError 不能再定义temp之前使用该变量
  let tmp;
}
// 原因：在块级作用域中使用let声明tmp变量，会出现暂时性死区，从错误描述信息中我们可以看出，并没有报出tmp is not defined，说明let声明也会存在变量创建时的提升，但并未对该变量进行初始化，所以在let声明之前访问tmp变量会报错
```

　

　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
// Math.min(...arr)
```

　

　

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别

* 1、var存在变量提示，let和const不存在变量提生
* 2、var可以重复声明一个变量，let和const不可以重复声明，会语法错误，letconst就不支持这么写
* 3、var不存在暂时性死区，如果声明之前使用了变量，会报undefined，let和const存在暂时性死区

　

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()  // 20
// 解释： 此处setTimeout中的回调函数使用了箭头函数，箭头函数不会改变this指向，由外部环境所决定，所以此处的this指的是fn内部调用时的this的指向，而fn是被obj调用，所以此时的this指向的是obj，所以输出结果为obj中的a，为20
```

　

　

### 6. 简述Symbol类型的用途
* 1、对象属性名的扩展，保证了属性名唯一性，属性值不会被覆盖的问题，
* 2、遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，但可以通过Object.getOwnPropertySymbols()方法获取


　

　

### 7. 说说什么是浅拷贝，什么是深拷贝？

* 浅拷贝：创建一个新的数据，这个数据有着原始数据属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个数据改变了这个地址，就会影响到另一个数据。
 * 深拷贝：深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。在堆中重新分配内存，拥有不同的地址，且值是一样的，复制后的对象与原来的对象是完全隔离，互不影响。
　

### 8. 请简述TypeScript与JavaScript之间的关系？

* TypeScript可以说是js的第二语言，让js这个弱类型语言增加了类型检查机制
* 减少低级错误的出现，比如编写时候的语法和类型等错误，提高代码质量
* 直接使用ES6+的新特性，兼容性好
* 增强了代码的可读性和可维护性，在编译阶段就可以发现大部分错误，不需要在运行时才发现
　

### 9. 请谈谈你所认为的typescript优缺点

* 缺点：需要一定的学习成本，小型项目会有点重了
* 优点：完善了js的类型，和类型检查机制，写代码会有类型提示

　

### 10. 描述引用计数的工作原理和优缺点
* 引用计数工作原理：变量被使用一次js引擎就会计数一次，释放一次就会减少一个计数
* 优点：1、发现垃圾立即回收，2、最大程度减少程序暂停，因为当js引擎发现内存快要被沾满的时候， 就会立即清除计数为0的垃圾数据
* 缺点：1、还要分配内存去维护计数数据，数据量大了比较耗性能2、无法回收循环引用的对象，比如obj1.name=obj2，此时obj2就不会被清除，因为引用计数为1
　

　

### 11. 描述标记整理算法的工作流程
从global开始找可达对象，如果还有子集，就进行递归查找，然后进行标记，全部查找完成，对没有进行标记的对象立即进行清除，同时也会对第一次标记的对象取消标记
　

　

### 12.描述V8中新生代存储区垃圾回收的流程

* 新生代存储区分为from和to两个等大空间，在from内存达到一定的大小的时候会进行标记整理
* 将活动对象复制到to内存区，然后将from进行释放
* 如果to的使用率超过25%，将会晋升到老生代存储区
* 经过一轮GC之后还存活的对象也会晋升到老生代存储区
* 对from和to进行置换

　

### 13. 描述增量标记算法在何时使用及工作原理
* 何时使用：老生代进行垃圾回收的遍历对象进行标记时，与程序执行交替进行使用

* 工作原理：将遍历对象的过程拆分成许多个小步骤，当触发垃圾回收时，先对所有的直接可达对象进行标记，然后会停下来等待程序代码执行一会，再交替将间接可达对象进行标记，最后进行回收操作
　

　